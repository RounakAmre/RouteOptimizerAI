
const state={map:null,stops:[],routeLine:null,lastRoute:null,lastOrder:null,schedule:null};
function initMap(){const c=[32.7767,-96.7970];state.map=L.map('map').setView(c,10);L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap'}).addTo(state.map);state.map.on('click',e=>addStop(e.latlng));q('#btnOptimize').addEventListener('click',()=>optimize(false));q('#btnAiOptimize').addEventListener('click',()=>optimize(true));q('#btnAiOptimize2').addEventListener('click',()=>optimize(true));q('#btnSavePersistent').addEventListener('click',()=>{localStorage.setItem('persistentPrompt',q('#persistentPrompt').value);q('#persistStatus').textContent='Saved';setTimeout(()=>q('#persistStatus').textContent='',1200)});q('#showNumbers')?.addEventListener('change',refreshMarkerNumbers);q('#persistentPrompt').value=localStorage.getItem('persistentPrompt')||'';render()}
function baseIcon(h,g=false){return L.divIcon({className:'num-icon',html:`<div class="bubble ${g?'ghost':''}">${h}</div>`,iconSize:[26,26],iconAnchor:[13,26],popupAnchor:[0,-28]})}
function addStop(latlng){const i=state.stops.length;const m=L.marker(latlng,{draggable:true,icon:baseIcon('â€¢',true)}).addTo(state.map);m.on('dragend',render);const s={marker:m,name:`Stop ${i+1}`,minutes:5,urgent:false,twStart:null,twEnd:null};state.stops.push(s);m.bindPopup(()=>popupHtml(s));render()}
function popupHtml(s){const {lat,lng}=s.marker.getLatLng();const tw=(s.twStart!=null&&s.twEnd!=null)?`${secToHHMM(s.twStart)}â€“${secToHHMM(s.twEnd)}`:'any time';return `<b>${esc(s.name)}</b><br/>${lat.toFixed(5)}, ${lng.toFixed(5)}<br/>${s.urgent?'ðŸš© Urgent':'Normal'} Â· ${s.minutes} min Â· ${tw}`}
function render(){const list=q('#stopList');list.innerHTML='';state.stops.forEach((s,i)=>{const r=document.createElement('div');r.className='stop';const {lat,lng}=s.marker.getLatLng();r.innerHTML=`<div class="grid">
<input type="text" value="${attr(s.name)}" data-i="${i}" data-f="name" placeholder="Stop name"/>
<input type="number" min="0" step="1" value="${s.minutes}" data-i="${i}" data-f="minutes"/>
<input type="time" value="${s.twStart!=null?secToHHMM(s.twStart):''}" data-i="${i}" data-f="twStart"/>
<input type="time" value="${s.twEnd!=null?secToHHMM(s.twEnd):''}" data-i="${i}" data-f="twEnd"/>
<label><input type="checkbox" ${s.urgent?'checked':''} data-i="${i}" data-f="urgent"/> Urgent</label>
<button class="del" data-i="${i}">âœ•</button>
</div><div class="muted">${lat.toFixed(5)}, ${lng.toFixed(5)}</div>`;list.appendChild(r)});list.querySelectorAll('input,button').forEach(el=>{if(el.tagName==='BUTTON')el.addEventListener('click',onDelete);else{el.addEventListener('input',onEdit);el.addEventListener('change',onEdit)}});refreshMarkerNumbers()}
function onDelete(e){const i=+e.target.dataset.i;state.map.removeLayer(state.stops[i].marker);state.stops.splice(i,1);state.lastOrder=null;state.schedule=null;render()}
function onEdit(e){const i=+e.target.dataset.i;const f=e.target.dataset.f;if(f==='name')state.stops[i].name=e.target.value;if(f==='minutes')state.stops[i].minutes=Math.max(0,+e.target.value||0);if(f==='urgent')state.stops[i].urgent=e.target.checked;if(f==='twStart')state.stops[i].twStart=e.target.value?hhmmToSec(e.target.value):null;if(f==='twEnd')state.stops[i].twEnd=e.target.value?hhmmToSec(e.target.value):null;state.stops[i].marker.setPopupContent(()=>popupHtml(state.stops[i]));render()}
async function optimize(useAI){if(state.stops.length<2)return;toggleBusy(true);try{const coords=state.stops.map(s=>s.marker.getLatLng());const coordStr=coords.map(c=>`${c.lng},${c.lat}`).join(';');const tRes=await fetch(`https://router.project-osrm.org/table/v1/driving/${coordStr}?annotations=duration`);if(!tRes.ok)throw new Error('Matrix request failed');const matrix=await tRes.json();if(!matrix.durations)throw new Error('Matrix missing durations');const dur=matrix.durations;const startSec=hhmmToSec(q('#routeStart').value||'08:00');let built;if(useAI){const ai=await getAIRules();built=await buildOrderAI(dur,startSec,ai)}else{built=buildWindowAwareOrder(dur,startSec)}state.lastOrder=built.order;state.schedule=built.schedule;const orderedStr=state.lastOrder.map(i=>`${coords[i].lng},${coords[i].lat}`).join(';');const rRes=await fetch(`https://router.project-osrm.org/route/v1/driving/${orderedStr}?overview=full&geometries=geojson`);if(!rRes.ok)throw new Error('Route request failed');const rData=await rRes.json();if(!rData.routes||!rData.routes[0])throw new Error('No route found');state.lastRoute=rData;drawRoute(rData.routes[0].geometry.coordinates)}catch(err){alert('Routing failed: '+err.message);console.error(err)}finally{toggleBusy(false);render()}}
async function getAIRules(){const persistent=(q('#persistentPrompt').value||localStorage.getItem('persistentPrompt')||'').trim();const adhoc=(q('#adHocPrompt').value||'').trim();const context={stops:state.stops.map((s,i)=>({idx:i,name:s.name,urgent:!!s.urgent,minutes:s.minutes||0,window:(s.twStart!=null&&s.twEnd!=null)?[secToHHMM(s.twStart),secToHHMM(s.twEnd)]:null}))};try{const res=await fetch('/ai/interpret',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({persistent,adhoc,context})});if(!res.ok)throw new Error('AI server error');const data=await res.json();return normalizeAIRules(data)}catch(e){console.warn('AI offline, using fallback',e);return fallbackInterpret(persistent+'\n'+adhoc)}}
function normalizeAIRules(r){return{priority:(r.priority||'balanced').toLowerCase(),avoidRoadNames:Array.isArray(r.avoid_road_names)?r.avoid_road_names.map(String):[],weights:{urgent:+(r.urgent_weight??1.0),lateness:+(r.lateness_weight??1.0),wait:+(r.wait_weight??0.1),avoidRoadPenalty:+(r.avoid_road_penalty??300)}}}
function fallbackInterpret(text){const avoid=[];const m=text.match(/avoid\s+([^\n]+)/ig);if(m){m.forEach(line=>{const names=line.replace(/avoid\s+/i,'').split(/[;,]| and /i).map(s=>s.trim()).filter(Boolean);avoid.push(...names)})}let priority=/prioriti(s|z)e\s+urgent/i.test(text)?'urgent':/prioriti(s|z)e\s+(time|window)/i.test(text)?'timewindow':'balanced';return normalizeAIRules({priority,avoid_road_names:avoid})}
function buildWindowAwareOrder(dur,startSec){const urgent=new Set(state.stops.map((s,i)=>s.urgent?i:-1).filter(i=>i>=0));const normal=new Set(state.stops.map((s,i)=>s.urgent?-1:i).filter(i=>i>=0));const order=[];const schedule=[];let current=0;let clock=startSec;order.push(current);const svc0=(state.stops[current].minutes||0)*60;schedule.push({idx:current,arrive:startSec,start:startSec,depart:startSec+svc0,feasible:windowFeasible(state.stops[current],startSec)});clock+=svc0;urgent.delete(current);normal.delete(current);while(urgent.size||normal.size){const pool=urgent.size?urgent:normal;let best=null,bestScore=Infinity,bestArrival=0,bestDepart=0,bestFeasible=false;pool.forEach(i=>{const travel=dur[current][i]||Infinity;const arrive=clock+travel;const {feasible,startSrv,depart}=applyWindow(state.stops[i],arrive);const lateness=feasible?0:Math.max(0,arrive-(state.stops[i].twEnd??arrive));const wait=Math.max(0,(state.stops[i].twStart??arrive)-arrive);const score=(feasible?0:1e6)+lateness+0.001*travel+0.0001*wait;if(score<bestScore){best=i;bestScore=score;bestArrival=arrive;bestDepart=depart;bestFeasible=feasible}});if(best==null)break;order.push(best);schedule.push({idx:best,arrive:bestArrival,start:bestDepart-(state.stops[best].minutes||0)*60,depart:bestDepart,feasible:bestFeasible});current=best;clock=bestDepart;urgent.delete(best);normal.delete(best)}if(q('#roundTrip')?.checked&&order[order.length-1]!==order[0]){order.push(order[0]);const travel=dur[current][order[0]]||0;const arrive=clock+travel;schedule.push({idx:order[0],arrive,start:arrive,depart:arrive,feasible:true})}return{order,schedule}}
async function buildOrderAI(dur,startSec,ai){const urgent=new Set(state.stops.map((s,i)=>s.urgent?i:-1).filter(i=>i>=0));const normal=new Set(state.stops.map((s,i)=>s.urgent?-1:i).filter(i=>i>=0));const order=[];const schedule=[];let current=0;let clock=startSec;order.push(current);const svc0=(state.stops[current].minutes||0)*60;schedule.push({idx:current,arrive:startSec,start:startSec,depart:startSec+svc0,feasible:windowFeasible(state.stops[current],startSec)});clock+=svc0;urgent.delete(current);normal.delete(current);while(urgent.size||normal.size){let pool=(ai.priority==='urgent'&&urgent.size)?urgent:(ai.priority==='timewindow'&&normal.size?normal:(urgent.size?urgent:normal));let best=null,bestScore=Infinity,bestArrival=0,bestDepart=0,bestFeasible=false;pool.forEach(i=>{const travel=dur[current][i]||Infinity;const arrive=clock+travel;const {feasible,startSrv,depart}=applyWindow(state.stops[i],arrive);const lateness=feasible?0:Math.max(0,arrive-(state.stops[i].twEnd??arrive));const wait=Math.max(0,(state.stops[i].twStart??arrive)-arrive);const urgentBoost=(state.stops[i].urgent?-(ai.weights?.urgent??1.0)*60:0);const score=(feasible?0:1e6)+(ai.weights?.lateness??1.0)*lateness+0.001*travel+(ai.weights?.wait??0.1)*wait+urgentBoost;if(score<bestScore){best=i;bestScore=score;bestArrival=arrive;bestDepart=depart;bestFeasible=feasible}});if(best==null)break;order.push(best);schedule.push({idx:best,arrive:bestArrival,start:bestDepart-(state.stops[best].minutes||0)*60,depart:bestDepart,feasible:bestFeasible});current=best;clock=bestDepart;if(urgent.has(best))urgent.delete(best);else normal.delete(best)}if(q('#roundTrip')?.checked&&order[order.length-1]!==order[0]){order.push(order[0]);const travel=dur[current][order[0]]||0;const arrive=clock+travel;schedule.push({idx:order[0],arrive,start:arrive,depart:arrive,feasible:true})}return{order,schedule}}
function windowFeasible(stop,arrive){if(stop.twStart==null||stop.twEnd==null)return true;return arrive<=stop.twEnd}
function applyWindow(stop,arrive){const svc=(stop.minutes||0)*60;let feasible=true;let startSrv=arrive;if(stop.twStart!=null&&arrive<stop.twStart)startSrv=stop.twStart;if(stop.twEnd!=null&&startSrv>stop.twEnd){feasible=false;startSrv=arrive}const depart=startSrv+svc;return{feasible,startSrv,depart}}
function drawRoute(coords){const latlngs=coords.map(([lon,lat])=>[lat,lon]);if(state.routeLine)state.map.removeLayer(state.routeLine);state.routeLine=L.polyline(latlngs,{weight:5,opacity:.95}).addTo(state.map);state.map.fitBounds(state.routeLine.getBounds(),{padding:[30,30]})}
function refreshMarkerNumbers(){const order=state.lastOrder;const show=q('#showNumbers')?.checked;if(!order||!show){state.stops.forEach(s=>s.marker.setIcon(baseIcon('â€¢',true)));return}order.forEach((idx,k)=>{const dup=(k===order.length-1)&&order[0]===idx&&order.length>1;const label=dup?'â®Œ':String(k+1);state.stops[idx].marker.setIcon(baseIcon(label,false))})}
function toggleBusy(b){['#btnOptimize','#btnAiOptimize','#btnAiOptimize2'].forEach(sel=>{const btn=q(sel);if(!btn)return;btn.textContent=b?'Optimizingâ€¦':(sel==='#btnAiOptimize2'?'Use AI + Optimize':(sel==='#btnAiOptimize'?'AI Optimize':'Optimize (Heuristic)'));btn.disabled=b||state.stops.length<2})}
function q(s){return document.querySelector(s)}function esc(s){return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}function attr(s){return esc(s).replace(/"/g,'&quot;')}function hhmmToSec(str){const [h,m]=str.split(':').map(Number);return(h*3600+m*60)|0}function secToHHMM(sec){sec=Math.max(0,Math.floor(sec));const h=Math.floor(sec/3600),m=Math.floor((sec%3600)/60);return String(h).padStart(2,'0')+':'+String(m).padStart(2,'0')}window.addEventListener('load',initMap);
